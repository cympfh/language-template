#!/bin/bash

function help {
  cat << HELP
NAME:
    template rust -- Rust Templates

SYNOPSIS:
    template rust

* Scanner クラスの工夫だけ
HELP
  exit 0
}

[ "_$1" = "_-h" -o "_$1" = "_--help" ] && help

cat << EOF
#![allow(unused_imports, unused_macros, dead_code)]

macro_rules! min {
    (.. \$x:expr) => {{
        let mut it = \$x.iter();
        it.next().map(|z| it.fold(z, |x, y| min!(x, y)))
    }};
    (\$x:expr) => (\$x);
    (\$x:expr, \$(\$ys:expr),*) => {{
        let t = min!(\$(\$ys),*);
        if \$x < t { \$x } else { t }
    }}
}
macro_rules! max {
    (.. \$x:expr) => {{
        let mut it = \$x.iter();
        it.next().map(|z| it.fold(z, |x, y| max!(x, y)))
    }};
    (\$x:expr) => (\$x);
    (\$x:expr, \$(\$ys:expr),*) => {{
        let t = max!(\$(\$ys),*);
        if \$x > t { \$x } else { t }
    }}
}
macro_rules! ewriteln {
    (\$(\$args:expr),*) => { let _ = writeln!(&mut std::io::stderr(), \$(\$args),*); };
}
macro_rules! trace {
    (\$x:expr) => { ewriteln!(">>> {} = {:?}", stringify!(\$x), \$x) };
    (\$(\$xs:expr),*) => { trace!((\$(\$xs),*)) }
}
macro_rules! put {
    (.. \$x:expr) => {{
        let mut it = \$x.iter();
        if let Some(x) = it.next() { print!("{}", x); }
        for x in it { print!(" {}", x); }
        println!("");
    }};
    (\$x:expr) => { println!("{}", \$x) };
    (\$x:expr, \$(\$xs:expr),*) => { print!("{} ", \$x); put!(\$(\$xs),*) }
}

const M: i64 = 1_000_000_007;

fn main() {
    let mut sc = Scanner::new();
    let n: usize = sc.cin();
    trace!(n);
}

use std::io::{self, Write};
use std::str::FromStr;
use std::collections::VecDeque;

struct Scanner { stdin: io::Stdin, buffer: VecDeque<String>, }
impl Scanner {
    fn new() -> Self { Scanner { stdin: io::stdin(), buffer: VecDeque::new() } }
    fn cin<T: FromStr>(&mut self) -> T {
        while self.buffer.len() == 0 {
            let mut line = String::new();
            let _ = self.stdin.read_line(&mut line);
            for w in line.split_whitespace() {
                self.buffer.push_back(String::from(w));
            }
        }
        self.buffer.pop_front().unwrap().parse::<T>().ok().unwrap()
    }
    fn chars(&mut self) -> Vec<char> { self.cin::<String>().chars().collect() }
    fn vec<T: FromStr>(&mut self, n: usize) -> Vec<T> { (0..n).map(|_| self.cin()).collect() }
}
EOF
